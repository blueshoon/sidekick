
# Pa11y Sidekick Architecture

Hello! This is Pa11y Sidekick's architecture guide. We're really excited to show you how to get started with contributing.

By the end of this guide, you should feel comfortable with the general architecture of the application. We also maintain sections geared towards people who specialise in different areas of development.

This guide does not cover basic running, testing, or deployment of Pa11y Sidekick. Refer to the [README] for these.


## Table of Contents

  - [Getting Started](#getting-started)
  - [The Basics](#the-basics)
  - [Back End](#back-end)
    - [Entry-Points](#entry-points)
    - [Controllers](#controllers)
    - [Middleware](#middleware)
    - [Logging](#logging)
  - [Front End](#front-end)
    - [View Templates](#view-templates)
      - [Layouts](#layouts)
      - [Partials](#partials)
    - [View Helpers](#view-helpers)
    - [Static Files](#static-files)
    - [CSS](#css)
    - [Client-Side JavaScript](#client-side-javascript)
  - [Databases](#databases)
    - [Models](#models)
    - [Migrations](#migrations)
    - [Seeding](#seeding)
  - [Testing](#testing)
    - [Unit Tests](#unit-tests)
    - [Integration Tests](#integration-tests)


## Getting Started

Pa11y Sidekick is a [Node.js] application. There are a few skills you'll need before understanding/contributing to different parts of the application. We recommend reading these sections after [the basics](#the-basics).

  - **[Back End](#back-end)**:<br/>
    Beginner–intermediate [Node.js] knowledge will be required. We make use of [Promises] via [async functions] for the core library and models. A working knowledge of [Express] is helpful but not required.

  - **[Front End](#front-end)**:<br/>
    Either HTML/CSS knowledge and/or client-side JavaScript knowledge will be required. For templating, we use [Dust.js]. An understanding of these is useful but not a prerequisite.

  - **[Databases](#databases)**:<br/>
    We use [PostgreSQL] to persist data, and the [Bookshelf] and [Knex.js] libraries to communicate with it.

Once you've read up on your preferred areas, you should also review the section on [testing](#testing).


## The Basics

OK, are you ready? This part of the guide covers things that are useful for all developers to know. We'll be covering the general application structure and where to find things.

The directory structure of Pa11y Sidekick can be seen below. We'll cover each of these folders in turn.

```
Sidekick
├── controller
├── data
│   ├── migration
│   └── seed
├── lib
│   └── middleware
├── model
├── public
├── script
├── test
│   ├── integration
│   └── unit
└── view
    ├── helper
    ├── layout
    ├── partial
    └── template
```

### The `controller` folder

This is where application controllers live. These files mostly handle routing through [Express]. [Read the controllers documentation](#controllers) for more information.

### The `data/migration` folder

This is where database migrations live. Migrations are handled by [Knex.js], and files in this folder are timestamped and generated by a script. [Read the migrations documentation](#migrations) for more information.

### The `data/seed` folder

This is where database seed data lives, seeding is handled by [Knex.js]. [Read the seeding documentation](#seeding) for more information.

### The `lib` folder

The `lib` folder is where the core code can be found – the files in here tie together the whole application. [Read the entry-points documentation](#entry-points) for more information.

### The `lib/middleware` folder

This folder contains [Express] middleware that is used by multiple routes. [Read the middleware documentation](#middleware) for more information.

### The `model` folder

This is where application models live – the only code that should interface with the database. These models use [Bookshelf] and [Knex.js]. [Read the models documentation](#models) for more information.

### The `public` folder

The `public` folder is used to serve static assets that don't require any additional back end logic applied, e.g. images. [Read the static files documentation](#static-files) for more information.

### The `script` folder

This folder contains Node.js scripts that are used as part of the build process. Most of these aren't interfaced with directly, they're used by [Make].

### The `test/integration` folder

This is where integration tests live. These tests build and run the entire application, and verify that each page is working as expected. [Read the integration tests documentation](#integration-tests) for more information.

### The `test/unit` folder

This folder is where the application's unit tests can be found. These test individual files and make heavy use of mocking. The directory structure in here mimics the main application structure. [Read the unit tests documentation](#unit-tests) for more information.

### The `view/helper` folder

This folder contains [Dust.js helpers and filters][dust helpers], which are JavaScript files. These are used to extend the templating language. [Read the view helpers documentation](#view-helpers) for more information.

### The `view/layout` folder

View layout templates live in here. These contain most of the boilerplate HTML required to render a page and are used by the application's view files. [Read the layouts documentation](#layouts) for more information.

### The `view/partial` folder

This is where view partials live. Partials are used to reduce repetition across the views, and when the same elements are needed on multiple pages. [Read the partials documentation](#partials) for more information.

### The `view/template` folder

This is where most of the application's view layer lives, this is mostly [Dust.js] files. [Read the view templates documentation](#view-templates) for more information.


## Back End

Hiya. If you're all caught up on the [application structure](#the-basics) then we can start looking into back end specific stuff in more detail! We'll be learning about the application core, how to create [Express] routes/controllers/middleware, and how to connect the different parts of the application. This section doesn't cover databases, that has [a section of its own](#databases).

### Entry-Points

The best place to start is with [`index.js`](../index.js). This is the main entry-point for the application. You'll notice that this file is very light-weight, that's because its only job is to take config values from the environment and pass them into the library code.

The `Dashboard` class comes from [`lib/dashboard.js`](../lib/dashboard.js), which is the most important file in the application – it ties everything else together. The file itself is commented, and should have excellent test coverage. If you're interested in making changes to this file, then head on over to it and read through the comments.

### Controllers

Controllers live in the `controller` folder and register multiple routes with [Express]. The controllers are split into files based on the part of the application that they relate to.

Each controller must export a function that accepts a single argument. That argument will be a `dashboard` object, which is created by [`lib/dashboard.js`](../lib/dashboard.js). When the application starts `lib/dashboard.js`, `controller/api-v1/index.js`, and `controller/front-end/index.js` decide which files are loaded – you'll need to modify one of these to load your new controller in.

Controllers often load and mount [other middleware](#middleware), as well as using [models](#models) to access the database. You should look into the existing controllers for examples of this.

### Middleware

Middleware can be used to reduce repetition between [controllers](#controllers), middleware files live in the `middleware` folder. These files don't have a prescribed structure or exports.

### Logging

For logging, we use [winston] and [morgan]. Winston is set up outside of the main application files in [`index.js`](../index.js), this allows us to inject a mock/silent logger in the [integration tests](#integration-tests).

Morgan is used to log requests, and this is mounted as an Express middleware. We actually stream morgan's request logs into winston under the `verbose` level. This allows users to easily ignore them by tweaking their preferred log level.


## Front End

OK, so you want to know how to work on Pa11y Sidekick's front end? Let's do it! This section will explain how to add templates (with [Dust.js]), ~CSS~, and ~client-side JavaScript~. We also cover static files.

### View Templates

View templates live in the `view` folder, and are written in the [Dust.js] templating language. We make use of [blocks and inline partials][dust-blocks] for template inheritance, and try to split repeated code into partials. Here's an example view:

```html
<!-- Extend the main layout -->
{>"layout/full"/}

<!-- insert the following into the layout title block -->
{< title}
    My Page
{/title}

<!-- insert the following into the layout content block -->
{< content}

    <h1>Hello World!</h1>

    <p>This is data from the controller: {example}</p>

{/content}
```

In order to see your view rendered in-browser, a controller will have to reference it. [Take a look at the controller documentation](#controllers) for more information on how to do this.

The `template/error.dust` view is a special one – it's used to render errors that get caught by the application.

#### Layouts

As mentioned above, we use [blocks and inline partials][dust-blocks] for template inheritance. This allows for multiple modifiable blocks in our layouts which each view can add data to.

The [main layout](../view/layout/full.dust) is used by most views; it provides boilerplate HTML and loads in the required scripts and styles.

#### Partials

Partials are used to reduce repetition in view files, and common markup patterns should be moved into partials. The best way to get acquainted with how we use partials is to [look through the folder](../view/partial).

### View Helpers

View helpers are used to extend the templating language, and to ensure that your views themselves don't have as much logic in them. You should avoid writing these unless absolutely necessary – try to get the data into the format you need in the controller first.

These files live in the `view/helper` folder; they should be JavaScript files that export a function which accepts a [Dust.js] instance as an argument:

```js
module.exports = dust => {
    dust.helpers.currentYear = chunk => {
        const year = (new Date()).getFullYear();
        return chunk.write(year);
    };
};
```

Read the [Dust.js helpers and filters][dust helpers] documentation for more information, or take a look at some of [the existing helpers](../view/helper).

### Static Files

All files in the `public` folder are served by an Express static middleware. This is where you should put images and assets that need no back end processing.

### CSS

TODO CSS should probably be compiled from Sass, we haven't written this yet. Currently All CSS is in a static file at [`public/main.css`](../public/main.css).

### Client-Side JavaScript

TODO client-side JavaScript should probably be compiled via Webpack or Browserify, we haven't written this yet. Currently there is no client-side JavaScript.


## Databases

Hello! This section will teach you how to manage Pa11y Sidekick's database. We'll be covering models, migrations, and seeding. We use [PostgreSQL] to persist data with [Bookshelf] and [Knex.js] as client libraries. We use [shortid] to create url-friendly unique identifiers.

### Models

Models live in the `model` folder and are used to access the database using [Bookshelf] as an ORM. Each model file represents a single table in the database, and consistency between models is encouraged.

Each model must export a function that accepts a single argument. That argument will be a `dashboard` object, which is created by [`lib/dashboard.js`](../lib/dashboard.js). The model function must return a Bookshelf model. You need to update `lib/dashboard.js` to include new models before they will be loaded in.

Models must be added to the `dashboard.model` object, so that they can be referenced as `dashboard.model.Example` in the rest of the codebase.

### Migrations

Migrations are created by using a script, you should never create these files manually. Run the following to create a new migration file:

```sh
./script/create-migration.js <migration-name>
```

The migration name should be descriptive of the changes you're making. Once you've created the migration file, it's worth copying the contents of an existing one so that the code style is the same. You should read the [Knex.js documentation on migrations][knex-migrations] for more information on the structure of these files.

Migrations can be run or rolled back using the following make targets (which correspond to files in the `script` folder):

```sh
make db-migrate-up
make db-migrate-down
```

### Seeding

Seed files live in `data/seed`, and are loaded into a database through either a Make target or automatically when [integration tests](#integration-tests) are run. It's useful to copy an existing seed file when adding new test data, also be aware that modifications to existing seed files may cause issues with the tests.

We split seed data into folders depending on their purpose. For example, `data/seed/demo` is the seed data used to demonstrate Sidekick, while `test/integration/seed/*` files are used in the integration tests.

For more information on the structure of these files, read the [Knex.js documentation on seeding][knex-seeding].

To use the demo seed data, you can run:

```sh
make db-seed
```


## Testing

Automated testing is an important part of working on Pa11y Sidekick, let's dig into how we do it!

### Unit Tests

Unit tests live in the `test/unit` folder, where the directory structure mimics the main structure.

Not all of the codebase is unit tested, we find that trying to unit test models and controllers doesn't really give us much benefit over just integration tests. The code that's extremely important to test is anything in the `lib` folder. We try to maintain ~100% coverage of the core code, and we also write tests for middleware currently.

For testing we use:

  - [Mocha] as a test framework
  - [Proclaim] as an assertion library
  - [Sinon] and [Mockery] for mocks and spies

Dig into the [`test/unit`](../test/unit) folder to get an idea of what our tests look like.

### Integration Tests

We try to maintain integration tests for all of Pa11y Sidekick's features. This means that we can feel confident that our changes haven't broken existing functionality, and that our changes won't be accidentally broken by a later commit.

The integration tests spin up the application in test mode and run the full stack from database to front end. We use the following tools:

  - [Mocha] as a test framework
  - [SuperTest] as an HTTP client and assertion library
  - [Sinon] and [Mockery] for mocks and spies

Dig into the [`test/integration`](../test/integration) folder to get an idea of what our tests look like.



[async functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function
[bookshelf]: http://bookshelfjs.org/
[browserify]: http://browserify.org/
[dust-blocks]: http://www.dustjs.com/guides/blocks/
[dust-helpers]: http://www.dustjs.com/docs/helper-api/
[dust.js]: http://www.dustjs.com/
[express]: http://expressjs.com/
[knex-migrations]: http://knexjs.org/#Migrations
[knex-seeding]: http://knexjs.org/#Seeds-API
[knex.js]: http://knexjs.org/
[make]: https://www.gnu.org/software/make/
[mocha]: https://mochajs.org/
[mockery]: https://github.com/mfncooper/mockery
[morgan]: https://github.com/expressjs/morgan
[node.js]: https://nodejs.org/
[postgresql]: http://www.postgresql.org/
[proclaim]: https://github.com/rowanmanning/proclaim
[promises]: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise
[readme]: ../README.md
[sass]: http://sass-lang.com/
[shortid]: https://github.com/dylang/shortid
[sinon]: http://sinonjs.org/
[supertest]: https://github.com/visionmedia/supertest
[winston]: https://github.com/winstonjs/winston
